<!DOCTYPE html>
<html lang="de">

<head>
    <title>wapp test</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <style>
        *,
        *::before,
        *::after {
            margin: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            width: 100vw;
            font: bold 11px sans-serif;
        }

        article {
            width: 1063px;
            height: 104.58px;
            outline: 1px solid gray;
            display: flex;
            padding: 0 30px 0 184px;
            /* border-left: 200px solid red; */
        }

        div.row {
            display: flex;
        }

        div.default {
            /* outline: 1px solid black; */
            padding: 1em;
            width: 25%;
        }

        div.more {
            padding: 1em;
            width: 33.33%;
        }

        div.less {
            padding: 1em;
            width: 20%;
        }

        div.high {
            padding: 1em;
            height: 5em;
        }
    </style>
    <script>
        function shade(hexstr, amt) {
            return hexstr.replace(/\w\w/g, c => (
                Math.min(255, Math.max(0, parseInt(c, 16) + amt)) + ','
            )).slice(1, -1);
        }

    </script>
</head>

<body>
    <div class="row">
        <div id="primary" class="default high">
            primary
        </div>
        <div id="secondary" class="default high">
            secondary
        </div>
        <div id="tertiary" class="default high">
            tertiary
        </div>
        <div id="error" class="default high">
            error
        </div>
    </div>

    <div class="row">
        <div id="onPrimary" class="default">
            onPrimary
        </div>
        <div id="onSecondary" class="default">
            onSecondary
        </div>
        <div id="onTertiary" class="default">
            onTertiary
        </div>
        <div id="onError" class="default">
            onError
        </div>
    </div>

    <div class="row">
        <div id="primaryContainer" class="default high">
            primaryContainer
        </div>
        <div id="secondaryContainer" class="default high">
            secondaryContainer
        </div>
        <div id="tertiaryContainer" class="default high">
            tertiaryContainer
        </div>
        <div id="errorContainer" class="default high">
            errorContainer
        </div>
    </div>

    <div class="row">
        <div id="onPrimaryContainer" class="default">
            onPrimaryContainer
        </div>
        <div id="onSecondaryContainer" class="default">
            onSecondaryContainer
        </div>
        <div id="onTertiaryContainer" class="default">
            onTertiaryContainer
        </div>
        <div id="onErrorContainer" class="default">
            onErrorContainer
        </div>
    </div>

    <div class="row">
        <div id="surfaceDim" class="more">
            surfaceDim
        </div>
        <div id="surface" class="more">
            surface
        </div>
        <div id="surfaceBright" class="more">
            surfaceBright
        </div>
    </div>

    <div class="row">
        <div id="surfaceContainerLowest" class="less">
            surfaceContainerLowest
        </div>
        <div id="surfaceContainerLow" class="less">
            surfaceContainerLow
        </div>
        <div id="surfaceContainer" class="less">
            surfaceContainer
        </div>
        <div id="surfaceContainerHigh" class="less">
            surfaceContainerHigh
        </div>
        <div id="surfaceContainerHighest" class="less">
            surfaceContainerHighest
        </div>
    </div>

    <div class="row">
        <div id="onSurface" class="default">
            onSurface
        </div>
        <div id="onSurfaceVariant" class="default">
            onSurfaceVariant
        </div>
        <div id="outline" class="default">
            outline
        </div>
        <div id="outlineVariant" class="default">
            outlineVariant
        </div>
    </div>

    <hr>
    dark
    <hr>
    <div class="row">
        <div id="primary2" class="default high">
            primary
        </div>
        <div id="secondary2" class="default high">
            secondary
        </div>
        <div id="tertiary2" class="default high">
            tertiary
        </div>
        <div id="error2" class="default high">
            error
        </div>
    </div>

    <div class="row">
        <div id="onPrimary2" class="default">
            onPrimary
        </div>
        <div id="onSecondary2" class="default">
            onSecondary
        </div>
        <div id="onTertiary2" class="default">
            onTertiary
        </div>
        <div id="onError2" class="default">
            onError
        </div>
    </div>

    <div class="row">
        <div id="primaryContainer2" class="default high">
            primaryContainer
        </div>
        <div id="secondaryContainer2" class="default high">
            secondaryContainer
        </div>
        <div id="tertiaryContainer2" class="default high">
            tertiaryContainer
        </div>
        <div id="errorContainer2" class="default high">
            errorContainer
        </div>
    </div>

    <div class="row">
        <div id="onPrimaryContainer2" class="default">
            onPrimaryContainer
        </div>
        <div id="onSecondaryContainer2" class="default">
            onSecondaryContainer
        </div>
        <div id="onTertiaryContainer2" class="default">
            onTertiaryContainer
        </div>
        <div id="onErrorContainer2" class="default">
            onErrorContainer
        </div>
    </div>

    <div class="row">
        <div id="surfaceDim2" class="more">
            surfaceDim
        </div>
        <div id="surface2" class="more">
            surface
        </div>
        <div id="surfaceBright2" class="more">
            surfaceBright
        </div>
    </div>

    <div class="row">
        <div id="surfaceContainerLowest2" class="less">
            surfaceContainerLowest
        </div>
        <div id="surfaceContainerLow2" class="less">
            surfaceContainerLow
        </div>
        <div id="surfaceContainer2" class="less">
            surfaceContainer
        </div>
        <div id="surfaceContainerHigh2" class="less">
            surfaceContainerHigh
        </div>
        <div id="surfaceContainerHighest2" class="less">
            surfaceContainerHighest
        </div>
    </div>

    <div class="row">
        <div id="onSurface2" class="default">
            onSurface
        </div>
        <div id="onSurfaceVariant2" class="default">
            onSurfaceVariant
        </div>
        <div id="outline2" class="default">
            outline
        </div>
        <div id="outlineVariant2" class="default">
            outlineVariant
        </div>
    </div>
    <script>

        const argbFromHex = (hex) => {
            hex = hex.replace("#", "");
            const isThree = hex.length === 3;
            const isSix = hex.length === 6;
            const isEight = hex.length === 8;
            if (!isThree && !isSix && !isEight) {
                throw new Error("unexpected hex " + hex);
            }
            let r = 0;
            let g = 0;
            let b = 0;
            if (isThree) {
                r = parseIntHex(hex.slice(0, 1).repeat(2));
                g = parseIntHex(hex.slice(1, 2).repeat(2));
                b = parseIntHex(hex.slice(2, 3).repeat(2));
            } else if (isSix) {
                r = parseIntHex(hex.slice(0, 2));
                g = parseIntHex(hex.slice(2, 4));
                b = parseIntHex(hex.slice(4, 6));
            } else if (isEight) {
                r = parseIntHex(hex.slice(2, 4));
                g = parseIntHex(hex.slice(4, 6));
                b = parseIntHex(hex.slice(6, 8));
            }
            return (255 << 24 | (r & 255) << 16 | (g & 255) << 8 | b & 255) >>> 0;
        };
        const hexFromArgb = (argb) => {
            const r = redFromArgb(argb);
            const g = greenFromArgb(argb);
            const b = blueFromArgb(argb);
            const outParts = [r.toString(16), g.toString(16), b.toString(16)];
            for (const [i, part] of outParts.entries()) {
                if (part.length === 1) {
                    outParts[i] = "0" + part;
                }
            }
            return "#" + outParts.join("");
        };

        function findCamByJ(hue, chroma, tone) {
            let low = 0;
            let high = 100;
            let mid = 0;
            let bestdL = 1e3;
            let bestdE = 1e3;
            let bestCam = null;
            while (Math.abs(low - high) > LIGHTNESS_SEARCH_ENDPOINT) {
                mid = low + (high - low) / 2;
                const camBeforeClip = CAM16.fromJch(mid, chroma, hue);
                const clipped = camBeforeClip.viewedInSrgb();
                const clippedLstar = lstarFromArgb(clipped);
                const dL = Math.abs(tone - clippedLstar);
                if (dL < DL_MAX) {
                    const camClipped = CAM16.fromInt(clipped);
                    const dE = camClipped.distance(CAM16.fromJch(camClipped.j, camClipped.chroma, hue));
                    if (dE <= DE_MAX && dE <= bestdE) {
                        bestdL = dL;
                        bestdE = dE;
                        bestCam = camClipped;
                    }
                }
                if (bestdL === 0 && bestdE === 0) {
                    break;
                }
                if (clippedLstar < tone) {
                    low = mid;
                } else {
                    high = mid;
                }
            }
            return bestCam;
        }
        class Scheme {
            constructor(props) {
                this.props = props;
            }
            get primary() {
                return this.props.primary;
            }
            get primaryContainer() {
                return this.props.primaryContainer;
            }
            get onPrimary() {
                return this.props.onPrimary;
            }
            get onPrimaryContainer() {
                return this.props.onPrimaryContainer;
            }
            get secondary() {
                return this.props.secondary;
            }
            get secondaryContainer() {
                return this.props.secondaryContainer;
            }
            get onSecondary() {
                return this.props.onSecondary;
            }
            get onSecondaryContainer() {
                return this.props.onSecondaryContainer;
            }
            get tertiary() {
                return this.props.tertiary;
            }
            get onTertiary() {
                return this.props.onTertiary;
            }
            get tertiaryContainer() {
                return this.props.tertiaryContainer;
            }
            get onTertiaryContainer() {
                return this.props.onTertiaryContainer;
            }
            get error() {
                return this.props.error;
            }
            get onError() {
                return this.props.onError;
            }
            get errorContainer() {
                return this.props.errorContainer;
            }
            get onErrorContainer() {
                return this.props.onErrorContainer;
            }
            get background() {
                return this.props.background;
            }
            get onBackground() {
                return this.props.onBackground;
            }
            get surface() {
                return this.props.surface;
            }
            get onSurface() {
                return this.props.onSurface;
            }
            get surfaceVariant() {
                return this.props.surfaceVariant;
            }
            get onSurfaceVariant() {
                return this.props.onSurfaceVariant;
            }


            get surfaceDim() {
                return this.props.surfaceDim;
            }
            get surfaceBright() {
                return this.props.surfaceBright;
            }
            get surfaceContainerLowest() {
                return this.props.surfaceContainerLowest;
            }
            get surfaceContainerLow() {
                return this.props.surfaceContainerLow;
            }
            get surfaceContainer() {
                return this.props.surfaceContainer;
            }
            get surfaceContainerHigh() {
                return this.props.surfaceContainerHigh;
            }
            get surfaceContainerHighest() {
                return this.props.surfaceContainerHighest;
            }

            get outline() {
                return this.props.outline;
            }

            get outlineVariant() {
                return this.props.outlineVariant;
            }
            get shadow() {
                return this.props.shadow;
            }
            get inverseSurface() {
                return this.props.inverseSurface;
            }
            get inverseOnSurface() {
                return this.props.inverseOnSurface;
            }
            get inversePrimary() {
                return this.props.inversePrimary;
            }
            static light(argb) {
                const core = CorePalette.of(argb);
                return new Scheme({
                    primary: core.a1.tone(40),
                    onPrimary: core.a1.tone(100),
                    primaryContainer: core.a1.tone(90),
                    onPrimaryContainer: core.a1.tone(10),
                    secondary: core.a2.tone(40),
                    onSecondary: core.a2.tone(100),
                    secondaryContainer: core.a2.tone(90),
                    onSecondaryContainer: core.a2.tone(10),
                    tertiary: core.a3.tone(40),
                    onTertiary: core.a3.tone(100),
                    tertiaryContainer: core.a3.tone(90),
                    onTertiaryContainer: core.a3.tone(10),
                    error: core.error.tone(40),
                    onError: core.error.tone(100),
                    errorContainer: core.error.tone(90),
                    onErrorContainer: core.error.tone(10),
                    background: core.n1.tone(99),
                    onBackground: core.n1.tone(10),
                    surface: core.n1.tone(98),
                    onSurface: core.n1.tone(10),
                    surfaceVariant: core.n2.tone(90),
                    onSurfaceVariant: core.n2.tone(30),
                    surfaceDim: core.n1.tone(87),
                    surfaceBright: core.n1.tone(98),
                    surfaceContainerLowest: core.n1.tone(100),
                    surfaceContainerLow: core.n1.tone(96),
                    surfaceContainer: core.n1.tone(94),
                    surfaceContainerHigh: core.n1.tone(92),
                    surfaceContainerHighest: core.n1.tone(90),
                    outline: core.n2.tone(50),
                    outlineVariant: core.n2.tone(80),
                    shadow: core.n1.tone(0),
                    inverseSurface: core.n1.tone(20),
                    inverseOnSurface: core.n1.tone(95),
                    inversePrimary: core.a1.tone(80)
                });
            }
            static dark(argb) {
                const core = CorePalette.of(argb);
                return new Scheme({
                    primary: core.a1.tone(80),
                    onPrimary: core.a1.tone(20),
                    primaryContainer: core.a1.tone(30),
                    onPrimaryContainer: core.a1.tone(90),
                    secondary: core.a2.tone(80),
                    onSecondary: core.a2.tone(20),
                    secondaryContainer: core.a2.tone(30),
                    onSecondaryContainer: core.a2.tone(90),
                    tertiary: core.a3.tone(80),
                    onTertiary: core.a3.tone(20),
                    tertiaryContainer: core.a3.tone(30),
                    onTertiaryContainer: core.a3.tone(90),
                    error: core.error.tone(80),
                    onError: core.error.tone(20),
                    errorContainer: core.error.tone(30),
                    onErrorContainer: core.error.tone(80),
                    background: core.n1.tone(10),
                    onBackground: core.n1.tone(90),
                    surface: core.n1.tone(6),
                    onSurface: core.n1.tone(90),
                    surfaceVariant: core.n2.tone(30),
                    onSurfaceVariant: core.n2.tone(80),
                    surfaceDim: core.n1.tone(6),
                    surfaceBright: core.n1.tone(24),
                    surfaceContainerLowest: core.n1.tone(4),
                    surfaceContainerLow: core.n1.tone(10),
                    surfaceContainer: core.n1.tone(12),
                    surfaceContainerHigh: core.n1.tone(17),
                    surfaceContainerHighest: core.n1.tone(22),
                    outline: core.n2.tone(60),
                    outlineVariant: core.n2.tone(30),
                    shadow: core.n1.tone(0),
                    inverseSurface: core.n1.tone(90),
                    inverseOnSurface: core.n1.tone(20),
                    inversePrimary: core.a1.tone(40)
                });
            }
            toJSON() {
                return Object.assign({}, this.props);
            }
        }

        const CHROMA_SEARCH_ENDPOINT = 0.4;
        const DE_MAX = 1;
        const DL_MAX = 0.2;
        const LIGHTNESS_SEARCH_ENDPOINT = 0.01;
        function getInt(hue, chroma, tone) {
            return getIntInViewingConditions(sanitizeDegreesDouble(hue), chroma, clampDouble(0, 100, tone), ViewingConditions.DEFAULT);
        }
        function getIntInViewingConditions(hue, chroma, tone, viewingConditions) {
            if (chroma < 1 || Math.round(tone) <= 0 || Math.round(tone) >= 100) {
                return argbFromLstar(tone);
            }
            hue = sanitizeDegreesDouble(hue);
            let high = chroma;
            let mid = chroma;
            let low = 0;
            let isFirstLoop = true;
            let answer = null;
            while (Math.abs(low - high) >= CHROMA_SEARCH_ENDPOINT) {
                const possibleAnswer = findCamByJ(hue, mid, tone);
                if (isFirstLoop) {
                    if (possibleAnswer != null) {
                        return possibleAnswer.viewed(viewingConditions);
                    } else {
                        isFirstLoop = false;
                        mid = low + (high - low) / 2;
                        continue;
                    }
                }
                if (possibleAnswer === null) {
                    high = mid;
                } else {
                    answer = possibleAnswer;
                    low = mid;
                }
                mid = low + (high - low) / 2;
            }
            if (answer === null) {
                return argbFromLstar(tone);
            }
            return answer.viewed(viewingConditions);
        }

        function matrixMultiply(row, matrix) {
            const a = row[0] * matrix[0][0] + row[1] * matrix[0][1] + row[2] * matrix[0][2];
            const b = row[0] * matrix[1][0] + row[1] * matrix[1][1] + row[2] * matrix[1][2];
            const c = row[0] * matrix[2][0] + row[1] * matrix[2][1] + row[2] * matrix[2][2];
            return [a, b, c];
        }

        function signum(num) {
            if (num < 0) {
                return -1;
            } else {
                if (num === 0) {
                    return 0;
                } else {
                    return 1;
                }
            }
        }
        function lerp(start, stop, amount) {
            return (1 - amount) * start + amount * stop;
        }
        function clampInt(min, max, input) {
            if (input < min) {
                return min;
            } else {
                if (input > max) {
                    return max;
                }
            }
            return input;
        }
        function clampDouble(min, max, input) {
            if (input < min) {
                return min;
            } else {
                if (input > max) {
                    return max;
                }
            }
            return input;
        }
        function sanitizeDegreesInt(degrees) {
            degrees = degrees % 360;
            if (degrees < 0) {
                degrees = degrees + 360;
            }
            return degrees;
        }
        function sanitizeDegreesDouble(degrees) {
            degrees = degrees % 360;
            if (degrees < 0) {
                degrees = degrees + 360;
            }
            return degrees;
        }
        function argbFromRgb(red, green, blue) {
            return (255 << 24 | (red & 255) << 16 | (green & 255) << 8 | blue & 255) >>> 0;
        }
        function alphaFromArgb(argb) {
            return argb >> 24 & 255;
        }
        function redFromArgb(argb) {
            return argb >> 16 & 255;
        }
        function greenFromArgb(argb) {
            return argb >> 8 & 255;
        }
        function blueFromArgb(argb) {
            return argb & 255;
        }
        function isOpaque(argb) {
            return alphaFromArgb(argb) >= 255;
        }
        function srgbToXyz() {
            return [
                [0.41233895, 0.35762064, 0.18051042],
                [0.2126, 0.7152, 0.0722],
                [0.01932141, 0.11916382, 0.95034478]
            ];
        }
        function xyzToSrgb() {
            return [
                [3.2406, -1.5372, -0.4986],
                [-0.9689, 1.8758, 0.0415],
                [0.0557, -0.204, 1.057]
            ];
        }
        function argbFromXyz(x, y, z) {
            const linearRgb = matrixMultiply([x, y, z], xyzToSrgb());
            const r = delinearized(linearRgb[0]);
            const g = delinearized(linearRgb[1]);
            const b = delinearized(linearRgb[2]);
            return argbFromRgb(r, g, b);
        }
        function xyzFromArgb(argb) {
            const r = linearized(redFromArgb(argb));
            const g = linearized(greenFromArgb(argb));
            const b = linearized(blueFromArgb(argb));
            return matrixMultiply([r, g, b], srgbToXyz());
        }
        function argbFromLab(l, a, b) {
            const whitePoint = whitePointD65();
            const fy = (l + 16) / 116;
            const fx = a / 500 + fy;
            const fz = fy - b / 200;
            const xNormalized = labInvf(fx);
            const yNormalized = labInvf(fy);
            const zNormalized = labInvf(fz);
            const x = xNormalized * whitePoint[0];
            const y = yNormalized * whitePoint[1];
            const z = zNormalized * whitePoint[2];
            return argbFromXyz(x, y, z);
        }
        function labFromArgb(argb) {
            const whitePoint = whitePointD65();
            const xyz = xyzFromArgb(argb);
            const xNormalized = xyz[0] / whitePoint[0];
            const yNormalized = xyz[1] / whitePoint[1];
            const zNormalized = xyz[2] / whitePoint[2];
            const fx = labF(xNormalized);
            const fy = labF(yNormalized);
            const fz = labF(zNormalized);
            const l = 116 * fy - 16;
            const a = 500 * (fx - fy);
            const b = 200 * (fy - fz);
            return [l, a, b];
        }
        function argbFromLstar(lstar) {
            const fy = (lstar + 16) / 116;
            const fz = fy;
            const fx = fy;
            const kappa = 24389 / 27;
            const epsilon = 216 / 24389;
            const lExceedsEpsilonKappa = lstar > 8;
            const y = lExceedsEpsilonKappa ? fy * fy * fy : lstar / kappa;
            const cubeExceedEpsilon = fy * fy * fy > epsilon;
            const x = cubeExceedEpsilon ? fx * fx * fx : lstar / kappa;
            const z = cubeExceedEpsilon ? fz * fz * fz : lstar / kappa;
            const whitePoint = whitePointD65();
            return argbFromXyz(x * whitePoint[0], y * whitePoint[1], z * whitePoint[2]);
        }
        function lstarFromArgb(argb) {
            const y = xyzFromArgb(argb)[1] / 100;
            const e = 216 / 24389;
            if (y <= e) {
                return 24389 / 27 * y;
            } else {
                const yIntermediate = Math.pow(y, 1 / 3);
                return 116 * yIntermediate - 16;
            }
        }
        function yFromLstar(lstar) {
            const ke = 8;
            if (lstar > ke) {
                return Math.pow((lstar + 16) / 116, 3) * 100;
            } else {
                return lstar / 24389 / 27 * 100;
            }
        }
        function linearized(rgbComponent) {
            const normalized = rgbComponent / 255;
            if (normalized <= 0.040449936) {
                return normalized / 12.92 * 100;
            } else {
                return Math.pow((normalized + 0.055) / 1.055, 2.4) * 100;
            }
        }
        function delinearized(rgbComponent) {
            const normalized = rgbComponent / 100;
            let delinearized2 = 0;
            if (normalized <= 31308e-7) {
                delinearized2 = normalized * 12.92;
            } else {
                delinearized2 = 1.055 * Math.pow(normalized, 1 / 2.4) - 0.055;
            }
            return clampInt(0, 255, Math.round(delinearized2 * 255));
        }

        function whitePointD65() {
            return [95.047, 100, 108.883];
        }

        class ViewingConditions {
            constructor(n, aw, nbb, ncb, c, nc, rgbD, fl, fLRoot, z) {
                this.n = n;
                this.aw = aw;
                this.nbb = nbb;
                this.ncb = ncb;
                this.c = c;
                this.nc = nc;
                this.rgbD = rgbD;
                this.fl = fl;
                this.fLRoot = fLRoot;
                this.z = z;
            }
            static make(whitePoint = whitePointD65(), adaptingLuminance = 200 / Math.PI * yFromLstar(50) / 100, backgroundLstar = 50, surround = 2, discountingIlluminant = false) {
                const xyz = whitePoint;
                const rW = xyz[0] * 0.401288 + xyz[1] * 0.650173 + xyz[2] * -0.051461;
                const gW = xyz[0] * -0.250268 + xyz[1] * 1.204414 + xyz[2] * 0.045854;
                const bW = xyz[0] * -2079e-6 + xyz[1] * 0.048952 + xyz[2] * 0.953127;
                const f = 0.8 + surround / 10;
                const c = f >= 0.9 ? lerp(0.59, 0.69, (f - 0.9) * 10) : lerp(0.525, 0.59, (f - 0.8) * 10);
                let d = discountingIlluminant ? 1 : f * (1 - 1 / 3.6 * Math.exp((-adaptingLuminance - 42) / 92));
                d = d > 1 ? 1 : d < 0 ? 0 : d;
                const nc = f;
                const rgbD = [
                    d * (100 / rW) + 1 - d,
                    d * (100 / gW) + 1 - d,
                    d * (100 / bW) + 1 - d
                ];
                const k = 1 / (5 * adaptingLuminance + 1);
                const k4 = k * k * k * k;
                const k4F = 1 - k4;
                const fl = k4 * adaptingLuminance + 0.1 * k4F * k4F * Math.cbrt(5 * adaptingLuminance);
                const n = yFromLstar(backgroundLstar) / whitePoint[1];
                const z = 1.48 + Math.sqrt(n);
                const nbb = 0.725 / Math.pow(n, 0.2);
                const ncb = nbb;
                const rgbAFactors = [
                    Math.pow(fl * rgbD[0] * rW / 100, 0.42),
                    Math.pow(fl * rgbD[1] * gW / 100, 0.42),
                    Math.pow(fl * rgbD[2] * bW / 100, 0.42)
                ];
                const rgbA = [
                    400 * rgbAFactors[0] / (rgbAFactors[0] + 27.13),
                    400 * rgbAFactors[1] / (rgbAFactors[1] + 27.13),
                    400 * rgbAFactors[2] / (rgbAFactors[2] + 27.13)
                ];
                const aw = (2 * rgbA[0] + rgbA[1] + 0.05 * rgbA[2]) * nbb;
                return new ViewingConditions(n, aw, nbb, ncb, c, nc, rgbD, fl, Math.pow(fl, 0.25), z);
            }
        }
        ViewingConditions.DEFAULT = ViewingConditions.make();

        class CAM16 {
            constructor(hue, chroma, j, q, m, s, jstar, astar, bstar) {
                this.hue = hue;
                this.chroma = chroma;
                this.j = j;
                this.q = q;
                this.m = m;
                this.s = s;
                this.jstar = jstar;
                this.astar = astar;
                this.bstar = bstar;
            }
            distance(other) {
                const dJ = this.jstar - other.jstar;
                const dA = this.astar - other.astar;
                const dB = this.bstar - other.bstar;
                const dEPrime = Math.sqrt(dJ * dJ + dA * dA + dB * dB);
                const dE = 1.41 * Math.pow(dEPrime, 0.63);
                return dE;
            }
            static fromInt(argb) {
                return CAM16.fromIntInViewingConditions(argb, ViewingConditions.DEFAULT);
            }
            static fromIntInViewingConditions(argb, viewingConditions) {
                const red = (argb & 16711680) >> 16;
                const green = (argb & 65280) >> 8;
                const blue = argb & 255;
                const redL = linearized(red);
                const greenL = linearized(green);
                const blueL = linearized(blue);
                const x = 0.41233895 * redL + 0.35762064 * greenL + 0.18051042 * blueL;
                const y = 0.2126 * redL + 0.7152 * greenL + 0.0722 * blueL;
                const z = 0.01932141 * redL + 0.11916382 * greenL + 0.95034478 * blueL;
                const rC = 0.401288 * x + 0.650173 * y - 0.051461 * z;
                const gC = -0.250268 * x + 1.204414 * y + 0.045854 * z;
                const bC = -2079e-6 * x + 0.048952 * y + 0.953127 * z;
                const rD = viewingConditions.rgbD[0] * rC;
                const gD = viewingConditions.rgbD[1] * gC;
                const bD = viewingConditions.rgbD[2] * bC;
                const rAF = Math.pow(viewingConditions.fl * Math.abs(rD) / 100, 0.42);
                const gAF = Math.pow(viewingConditions.fl * Math.abs(gD) / 100, 0.42);
                const bAF = Math.pow(viewingConditions.fl * Math.abs(bD) / 100, 0.42);
                const rA = signum(rD) * 400 * rAF / (rAF + 27.13);
                const gA = signum(gD) * 400 * gAF / (gAF + 27.13);
                const bA = signum(bD) * 400 * bAF / (bAF + 27.13);
                const a = (11 * rA + -12 * gA + bA) / 11;
                const b = (rA + gA - 2 * bA) / 9;
                const u = (20 * rA + 20 * gA + 21 * bA) / 20;
                const p2 = (40 * rA + 20 * gA + bA) / 20;
                const atan2 = Math.atan2(b, a);
                const atanDegrees = atan2 * 180 / Math.PI;
                const hue = atanDegrees < 0 ? atanDegrees + 360 : atanDegrees >= 360 ? atanDegrees - 360 : atanDegrees;
                const hueRadians = hue * Math.PI / 180;
                const ac = p2 * viewingConditions.nbb;
                const j = 100 * Math.pow(ac / viewingConditions.aw, viewingConditions.c * viewingConditions.z);
                const q = 4 / viewingConditions.c * Math.sqrt(j / 100) * (viewingConditions.aw + 4) * viewingConditions.fLRoot;
                const huePrime = hue < 20.14 ? hue + 360 : hue;
                const eHue = 0.25 * (Math.cos(huePrime * Math.PI / 180 + 2) + 3.8);
                const p1 = 5e4 / 13 * eHue * viewingConditions.nc * viewingConditions.ncb;
                const t = p1 * Math.sqrt(a * a + b * b) / (u + 0.305);
                const alpha = Math.pow(t, 0.9) * Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73);
                const c = alpha * Math.sqrt(j / 100);
                const m = c * viewingConditions.fLRoot;
                const s = 50 * Math.sqrt(alpha * viewingConditions.c / (viewingConditions.aw + 4));
                const jstar = (1 + 100 * 7e-3) * j / (1 + 7e-3 * j);
                const mstar = 1 / 0.0228 * Math.log(1 + 0.0228 * m);
                const astar = mstar * Math.cos(hueRadians);
                const bstar = mstar * Math.sin(hueRadians);
                return new CAM16(hue, c, j, q, m, s, jstar, astar, bstar);
            }
            static fromJch(j, c, h) {
                return CAM16.fromJchInViewingConditions(j, c, h, ViewingConditions.DEFAULT);
            }
            static fromJchInViewingConditions(j, c, h, viewingConditions) {
                const q = 4 / viewingConditions.c * Math.sqrt(j / 100) * (viewingConditions.aw + 4) * viewingConditions.fLRoot;
                const m = c * viewingConditions.fLRoot;
                const alpha = c / Math.sqrt(j / 100);
                const s = 50 * Math.sqrt(alpha * viewingConditions.c / (viewingConditions.aw + 4));
                const hueRadians = h * Math.PI / 180;
                const jstar = (1 + 100 * 7e-3) * j / (1 + 7e-3 * j);
                const mstar = 1 / 0.0228 * Math.log(1 + 0.0228 * m);
                const astar = mstar * Math.cos(hueRadians);
                const bstar = mstar * Math.sin(hueRadians);
                return new CAM16(h, c, j, q, m, s, jstar, astar, bstar);
            }
            static fromUcs(jstar, astar, bstar) {
                return CAM16.fromUcsInViewingConditions(jstar, astar, bstar, ViewingConditions.DEFAULT);
            }
            static fromUcsInViewingConditions(jstar, astar, bstar, viewingConditions) {
                const a = astar;
                const b = bstar;
                const m = Math.sqrt(a * a + b * b);
                const M = (Math.exp(m * 0.0228) - 1) / 0.0228;
                const c = M / viewingConditions.fLRoot;
                let h = Math.atan2(b, a) * (180 / Math.PI);
                if (h < 0) {
                    h += 360;
                }
                const j = jstar / (1 - (jstar - 100) * 7e-3);
                return CAM16.fromJchInViewingConditions(j, c, h, viewingConditions);
            }
            viewedInSrgb() {
                return this.viewed(ViewingConditions.DEFAULT);
            }
            viewed(viewingConditions) {
                const alpha = this.chroma === 0 || this.j === 0 ? 0 : this.chroma / Math.sqrt(this.j / 100);
                const t = Math.pow(alpha / Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73), 1 / 0.9);
                const hRad = this.hue * Math.PI / 180;
                const eHue = 0.25 * (Math.cos(hRad + 2) + 3.8);
                const ac = viewingConditions.aw * Math.pow(this.j / 100, 1 / viewingConditions.c / viewingConditions.z);
                const p1 = eHue * (5e4 / 13) * viewingConditions.nc * viewingConditions.ncb;
                const p2 = ac / viewingConditions.nbb;
                const hSin = Math.sin(hRad);
                const hCos = Math.cos(hRad);
                const gamma = 23 * (p2 + 0.305) * t / (23 * p1 + 11 * t * hCos + 108 * t * hSin);
                const a = gamma * hCos;
                const b = gamma * hSin;
                const rA = (460 * p2 + 451 * a + 288 * b) / 1403;
                const gA = (460 * p2 - 891 * a - 261 * b) / 1403;
                const bA = (460 * p2 - 220 * a - 6300 * b) / 1403;
                const rCBase = Math.max(0, 27.13 * Math.abs(rA) / (400 - Math.abs(rA)));
                const rC = signum(rA) * (100 / viewingConditions.fl) * Math.pow(rCBase, 1 / 0.42);
                const gCBase = Math.max(0, 27.13 * Math.abs(gA) / (400 - Math.abs(gA)));
                const gC = signum(gA) * (100 / viewingConditions.fl) * Math.pow(gCBase, 1 / 0.42);
                const bCBase = Math.max(0, 27.13 * Math.abs(bA) / (400 - Math.abs(bA)));
                const bC = signum(bA) * (100 / viewingConditions.fl) * Math.pow(bCBase, 1 / 0.42);
                const rF = rC / viewingConditions.rgbD[0];
                const gF = gC / viewingConditions.rgbD[1];
                const bF = bC / viewingConditions.rgbD[2];
                const x = 1.86206786 * rF - 1.01125463 * gF + 0.14918677 * bF;
                const y = 0.38752654 * rF + 0.62144744 * gF - 897398e-8 * bF;
                const z = -0.0158415 * rF - 0.03412294 * gF + 1.04996444 * bF;
                const argb = argbFromXyz(x, y, z);
                return argb;
            }
        }

        class HCT {
            constructor(internalHue, internalChroma, internalTone) {
                this.internalHue = internalHue;
                this.internalChroma = internalChroma;
                this.internalTone = internalTone;
                this.setInternalState(this.toInt());
            }
            static from(hue, chroma, tone) {
                return new HCT(hue, chroma, tone);
            }
            static fromInt(argb) {
                const cam = CAM16.fromInt(argb);
                const tone = lstarFromArgb(argb);
                return new HCT(cam.hue, cam.chroma, tone);
            }
            toInt() {
                return getInt(this.internalHue, this.internalChroma, this.internalTone);
            }
            get hue() {
                return this.internalHue;
            }
            set hue(newHue) {
                this.setInternalState(getInt(sanitizeDegreesDouble(newHue), this.internalChroma, this.internalTone));
            }
            get chroma() {
                return this.internalChroma;
            }
            set chroma(newChroma) {
                this.setInternalState(getInt(this.internalHue, newChroma, this.internalTone));
            }
            get tone() {
                return this.internalTone;
            }
            set tone(newTone) {
                this.setInternalState(getInt(this.internalHue, this.internalChroma, newTone));
            }
            setInternalState(argb) {
                const cam = CAM16.fromInt(argb);
                const tone = lstarFromArgb(argb);
                this.internalHue = cam.hue;
                this.internalChroma = cam.chroma;
                this.internalTone = tone;
            }
        }

        class TonalPalette {
            constructor(hue, chroma) {
                this.hue = hue;
                this.chroma = chroma;
                this.cache = new Map();
            }
            static fromInt(argb) {
                const hct = HCT.fromInt(argb);
                return TonalPalette.fromHueAndChroma(hct.hue, hct.chroma);
            }
            static fromHueAndChroma(hue, chroma) {
                return new TonalPalette(hue, chroma);
            }
            tone(tone) {
                let argb = this.cache.get(tone);
                if (argb === void 0) {
                    argb = HCT.from(this.hue, this.chroma, tone).toInt();
                    this.cache.set(tone, argb);
                }
                return argb;
            }
        }

        class CorePalette {
            constructor(argb) {
                const hct = HCT.fromInt(argb);
                const hue = hct.hue;
                this.a1 = TonalPalette.fromHueAndChroma(hue, Math.max(48, hct.chroma));
                this.a2 = TonalPalette.fromHueAndChroma(hue, 16);
                this.a3 = TonalPalette.fromHueAndChroma(hue + 60, 24);
                this.n1 = TonalPalette.fromHueAndChroma(hue, 4);
                this.n2 = TonalPalette.fromHueAndChroma(hue, 8);
                this.error = TonalPalette.fromHueAndChroma(25, 84);
            }
            static of(argb) {
                return new CorePalette(argb);
            }
        }

        function themeFromSourceColor(source, customColors = []) {
            const palette = CorePalette.of(source);
            return {
                source,
                schemes: {
                    light: Scheme.light(source),
                    dark: Scheme.dark(source)
                },
                palettes: {
                    primary: palette.a1,
                    secondary: palette.a2,
                    tertiary: palette.a3,
                    neutral: palette.n1,
                    neutralVariant: palette.n2,
                    error: palette.error
                }
            };
        }

        function parseIntHex(value) {
            return parseInt(value, 16);
        }

        /*         const s = themeFromSourceColor(argbFromHex('#111cff'));
                for (let [key, value] of Object.entries(s.schemes.light.props)) {
                    //console.log(key, hexFromArgb(value))
                    let div = document.createElement('div')
                    div.style.backgroundColor = hexFromArgb(value);
                    div.textContent = `${key} ${hexFromArgb(value)}`
                    document.body.appendChild(div)
                } */
        const theme = themeFromSourceColor(argbFromHex('#6750a4'));
        primary.style.color = hexFromArgb(theme.schemes.light.props.onPrimary);
        primary.style.backgroundColor = hexFromArgb(theme.schemes.light.props.primary);

        secondary.style.color = hexFromArgb(theme.schemes.light.props.onSecondary);
        secondary.style.backgroundColor = hexFromArgb(theme.schemes.light.props.secondary);

        tertiary.style.color = hexFromArgb(theme.schemes.light.props.onTertiary);
        tertiary.style.backgroundColor = hexFromArgb(theme.schemes.light.props.tertiary);

        error.style.color = hexFromArgb(theme.schemes.light.props.onError);
        error.style.backgroundColor = hexFromArgb(theme.schemes.light.props.error);

        onPrimary.style.backgroundColor = hexFromArgb(theme.schemes.light.props.onPrimary);
        onPrimary.style.color = hexFromArgb(theme.schemes.light.props.primary);

        onSecondary.style.backgroundColor = hexFromArgb(theme.schemes.light.props.onSecondary);
        onSecondary.style.color = hexFromArgb(theme.schemes.light.props.secondary);

        onTertiary.style.backgroundColor = hexFromArgb(theme.schemes.light.props.onTertiary);
        onTertiary.style.color = hexFromArgb(theme.schemes.light.props.tertiary);

        onError.style.backgroundColor = hexFromArgb(theme.schemes.light.props.onError);
        onError.style.color = hexFromArgb(theme.schemes.light.props.error);
        /*  */
        primaryContainer.style.color = hexFromArgb(theme.schemes.light.props.onPrimaryContainer);
        primaryContainer.style.backgroundColor = hexFromArgb(theme.schemes.light.props.primaryContainer);

        secondaryContainer.style.color = hexFromArgb(theme.schemes.light.props.onSecondaryContainer);
        secondaryContainer.style.backgroundColor = hexFromArgb(theme.schemes.light.props.secondaryContainer);

        tertiaryContainer.style.color = hexFromArgb(theme.schemes.light.props.onTertiaryContainer);
        tertiaryContainer.style.backgroundColor = hexFromArgb(theme.schemes.light.props.tertiaryContainer);

        errorContainer.style.color = hexFromArgb(theme.schemes.light.props.onErrorContainer);
        errorContainer.style.backgroundColor = hexFromArgb(theme.schemes.light.props.errorContainer);

        onPrimaryContainer.style.backgroundColor = hexFromArgb(theme.schemes.light.props.onPrimaryContainer);
        onPrimaryContainer.style.color = hexFromArgb(theme.schemes.light.props.primaryContainer);

        onSecondaryContainer.style.backgroundColor = hexFromArgb(theme.schemes.light.props.onSecondaryContainer);
        onSecondaryContainer.style.color = hexFromArgb(theme.schemes.light.props.secondaryContainer);

        onTertiaryContainer.style.backgroundColor = hexFromArgb(theme.schemes.light.props.onTertiaryContainer);
        onTertiaryContainer.style.color = hexFromArgb(theme.schemes.light.props.tertiaryContainer);

        onErrorContainer.style.backgroundColor = hexFromArgb(theme.schemes.light.props.onErrorContainer);
        onErrorContainer.style.color = hexFromArgb(theme.schemes.light.props.errorContainer);
        /*  */
        surfaceDim.style.color = hexFromArgb(theme.schemes.light.props.onSurface);
        surfaceDim.style.backgroundColor = hexFromArgb(theme.schemes.light.props.surfaceDim);

        surface.style.color = hexFromArgb(theme.schemes.light.props.onSurface);
        surface.style.backgroundColor = hexFromArgb(theme.schemes.light.props.surface);

        surfaceBright.style.color = hexFromArgb(theme.schemes.light.props.onSurface);
        surfaceBright.style.backgroundColor = hexFromArgb(theme.schemes.light.props.surfaceBright);
        /*  */
        surfaceContainerLowest.style.color = hexFromArgb(theme.schemes.light.props.onSurface);
        surfaceContainerLowest.style.backgroundColor = hexFromArgb(theme.schemes.light.props.surfaceContainerLowest);

        surfaceContainerLow.style.color = hexFromArgb(theme.schemes.light.props.onSurface);
        surfaceContainerLow.style.backgroundColor = hexFromArgb(theme.schemes.light.props.surfaceContainerLow);

        surfaceContainer.style.color = hexFromArgb(theme.schemes.light.props.onSurface);
        surfaceContainer.style.backgroundColor = hexFromArgb(theme.schemes.light.props.surfaceContainer);

        surfaceContainerHigh.style.color = hexFromArgb(theme.schemes.light.props.onSurface);
        surfaceContainerHigh.style.backgroundColor = hexFromArgb(theme.schemes.light.props.surfaceContainerHigh);

        surfaceContainerHighest.style.color = hexFromArgb(theme.schemes.light.props.onSurface);
        surfaceContainerHighest.style.backgroundColor = hexFromArgb(theme.schemes.light.props.surfaceContainerHighest);
        /*  */
        onSurface.style.color = hexFromArgb(theme.schemes.light.props.surface);
        onSurface.style.backgroundColor = hexFromArgb(theme.schemes.light.props.onSurface);

        onSurfaceVariant.style.color = hexFromArgb(theme.schemes.light.props.surface);
        onSurfaceVariant.style.backgroundColor = hexFromArgb(theme.schemes.light.props.onSurfaceVariant);

        outline.style.color = hexFromArgb(theme.schemes.light.props.outlineVariant);
        outline.style.backgroundColor = hexFromArgb(theme.schemes.light.props.outline);

        outlineVariant.style.color = hexFromArgb(theme.schemes.light.props.outline);
        outlineVariant.style.backgroundColor = hexFromArgb(theme.schemes.light.props.outlineVariant);
        /* -------------- */
        primary2.style.color = hexFromArgb(theme.schemes.dark.props.onPrimary);
        primary2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.primary);

        secondary2.style.color = hexFromArgb(theme.schemes.dark.props.onSecondary);
        secondary2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.secondary);

        tertiary2.style.color = hexFromArgb(theme.schemes.dark.props.onTertiary);
        tertiary2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.tertiary);

        error2.style.color = hexFromArgb(theme.schemes.dark.props.onError);
        error2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.error);

        onPrimary2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.onPrimary);
        onPrimary2.style.color = hexFromArgb(theme.schemes.dark.props.primary);

        onSecondary2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.onSecondary);
        onSecondary2.style.color = hexFromArgb(theme.schemes.dark.props.secondary);

        onTertiary2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.onTertiary);
        onTertiary2.style.color = hexFromArgb(theme.schemes.dark.props.tertiary);

        onError2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.onError);
        onError2.style.color = hexFromArgb(theme.schemes.dark.props.error);
        /*  */
        primaryContainer2.style.color = hexFromArgb(theme.schemes.dark.props.onPrimaryContainer);
        primaryContainer2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.primaryContainer);

        secondaryContainer2.style.color = hexFromArgb(theme.schemes.dark.props.onSecondaryContainer);
        secondaryContainer2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.secondaryContainer);

        tertiaryContainer2.style.color = hexFromArgb(theme.schemes.dark.props.onTertiaryContainer);
        tertiaryContainer2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.tertiaryContainer);

        errorContainer2.style.color = hexFromArgb(theme.schemes.dark.props.onErrorContainer);
        errorContainer2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.errorContainer);

        onPrimaryContainer2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.onPrimaryContainer);
        onPrimaryContainer2.style.color = hexFromArgb(theme.schemes.dark.props.primaryContainer);

        onSecondaryContainer2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.onSecondaryContainer);
        onSecondaryContainer2.style.color = hexFromArgb(theme.schemes.dark.props.secondaryContainer);

        onTertiaryContainer2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.onTertiaryContainer);
        onTertiaryContainer2.style.color = hexFromArgb(theme.schemes.dark.props.tertiaryContainer);

        onErrorContainer2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.onErrorContainer);
        onErrorContainer2.style.color = hexFromArgb(theme.schemes.dark.props.errorContainer);
        /*  */
        surfaceDim2.style.color = hexFromArgb(theme.schemes.dark.props.onSurface);
        surfaceDim2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.surfaceDim);

        surface2.style.color = hexFromArgb(theme.schemes.dark.props.onSurface);
        surface2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.surface);

        surfaceBright2.style.color = hexFromArgb(theme.schemes.dark.props.onSurface);
        surfaceBright2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.surfaceBright);
        /*  */
        surfaceContainerLowest2.style.color = hexFromArgb(theme.schemes.dark.props.onSurface);
        surfaceContainerLowest2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.surfaceContainerLowest);

        surfaceContainerLow2.style.color = hexFromArgb(theme.schemes.dark.props.onSurface);
        surfaceContainerLow2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.surfaceContainerLow);

        surfaceContainer2.style.color = hexFromArgb(theme.schemes.dark.props.onSurface);
        surfaceContainer2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.surfaceContainer);

        surfaceContainerHigh2.style.color = hexFromArgb(theme.schemes.dark.props.onSurface);
        surfaceContainerHigh2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.surfaceContainerHigh);

        surfaceContainerHighest2.style.color = hexFromArgb(theme.schemes.dark.props.onSurface);
        surfaceContainerHighest2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.surfaceContainerHighest);
        /*  */
        onSurface2.style.color = hexFromArgb(theme.schemes.dark.props.surface);
        onSurface2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.onSurface);

        onSurfaceVariant2.style.color = hexFromArgb(theme.schemes.dark.props.surface);
        onSurfaceVariant2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.onSurfaceVariant);

        outline2.style.color = hexFromArgb(theme.schemes.dark.props.outlineVariant);
        outline2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.outline);

        outlineVariant2.style.color = hexFromArgb(theme.schemes.dark.props.outline);
        outlineVariant2.style.backgroundColor = hexFromArgb(theme.schemes.dark.props.outlineVariant);

        for (let [key, value] of Object.entries(theme.schemes.light.props)) {
            const found = key.match(/[A-Z]?[a-z]+/g);
            console.log("--color-light-"+found.join('-').toLowerCase()+" "+hexFromArgb(value))
        }

        for (let [key, value] of Object.entries(theme.schemes.dark.props)) {

        }
    </script>
</body>

</html>